"""Utilities for maintaining and asserting LICENSE and COPYRIGHT in
LSST DM repos.
"""

import shutil
import os
import fnmatch
import tempfile
import re

import git


comment_pattern = re.compile(
    '(?P<comment_flag>^[#* ])(?P<content>[\d\w\s<]*)')


def convert_boilerplate(code_stream):
    """Convert old-style licensing boilerplate (with full GPLv3) to RFC-45
    style.

    Parameters
    ----------
    code_stream : file-like object
        File handle to code.

    Returns
    -------
    converted_text : str
        Converted code text, as a string.
    """
    # Text for the new copyright/license boilerplate
    template_lines = [
        '{comment} See the COPYRIGHT and LICENSE files in the top-level '
        'directory of this\n',
        '{comment} package for notices and licensing terms.\n'
    ]
    lines = code_stream.readlines()
    new_lines = []
    omitting_mode = False
    for line in lines:
        m = comment_pattern.match(line)
        if m is None:
            # Pass through of non-comment characters
            new_lines.append(line)
            continue

        content = m.group('content').lstrip()
        if m is not None and content.startswith('Copyright'):
            # Trigger replacement at start of Copyright block
            for template_line in template_lines:
                new_lines.append(
                    template_line.format(comment=m.group('comment_flag')))
            omitting_mode = True
        elif content.startswith('see <http'):  # NOQA
            # End replacement mode
            omitting_mode = False
        elif omitting_mode is False:
            # Pass through mode
            if line.rstrip() == '#':
                # remove whitespace from comment header/footer for Python
                new_lines.append('#\n')
            else:
                new_lines.append(line)
    return ''.join(new_lines)


def upgrade_repo(gh, github_repo, branch_name):
    """Process a repository and upgrade licensing/copyright to RFC-45 style.

    Parameters
    ----------
    gh : obj
        A GitHub session, usually created by
        :func:`codekit.codetools.login_github`.
    github_repo : obj
        A GitHub repo, generated by `github3`.
    branch_name : str
        Name of the branch to create from master and commit in.
    """
    # Clone repo
    temp_dir = tempfile.mkdtemp()
    repo = git.Repo.clone_from(github_repo.clone_url, temp_dir)

    # Create a ticket branch to work in
    ticket_branch = repo.create_head(branch_name)
    ticket_branch.checkout()
    # repo.head.reference = ticket_branch

    # Covert boilerplate
    for filepath in all_files(temp_dir, patterns=('*.py', '*.cpp', '*.h')):
        with open(filepath, 'r') as f:
            new_code = convert_boilerplate(f)
        with open(filepath, 'w') as f:
            f.write(new_code)
        repo.index.add([filepath])
    if repo.is_dirty():
        repo.index.commit('Upgrade license and copyright according to RFC-45')

    # push branch to remote
    remote = repo.remote(name='origin')
    refspec = 'refs/heads/{br}:refs/heads/{br}'.format(br=branch_name)
    remote.push(refspec=refspec)

    # Delete local clone
    # FIXME turn temp dir into a context to ensure it is deleted on exit
    shutil.rmtree(temp_dir)


def all_files(root, patterns=('*',)):
    # Expand patterns from semicolon-separated string to list
    """Iterate through files matching a pattern.

    Adapted from Receipe 2.16 of the Python Cookbook, 2nd Ed [1].

    Parameters
    ----------
    root : str
        Root directory to process files in.
    patterns : tuple
        An iterable of strings for searching filenames.
        e.g. ``('*.py*, '*.cpp')``.

    Yields
    ------
    path : str
        Path to a file matching the `patterns`.

    References
    ----------
    .. [1] Martelli, A., Ravenscroft, A., & Ascher, D. (2005). *Python
       Cookbook.* O'Reilly Media, Inc..
    """
    for path, subdirs, files in os.walk(root):
        files.sort()
        for name in files:
            for pattern in patterns:
                if fnmatch.fnmatch(name, pattern):
                    yield os.path.join(path, name)
                    break
