#!/usr/bin/env python3

from codekit.codetools import debug, error, info
from codekit import codetools, pygithub
import argparse
import github
import os
import re
import sys
import textwrap


class GitTagExistsError(Exception):
    pass


def parse_args():
    """Parse command-line arguments"""
    prog = 'github-tag-teams'

    parser = argparse.ArgumentParser(
        prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent("""

        Tag the head of the default branch of all repositories in a GitHub org
        which belong to the specified team(s).

        Examples:
        {prog} --org lsst --team 'DM Auxilliaries' --tag w.2015.33

        Note that the access token must have access to these oauth scopes:
            * read:org
            * repo

        The token generated by `github-auth --user` should have sufficient
        permissions.
        """).format(prog=prog),
        epilog='Part of codekit: https://github.com/lsst-sqre/sqre-codekit'
    )

    parser.add_argument(
        '--tag',
        action='append',
        required=True,
        help="tag to apply to HEAD of repo (can specify several times")
    parser.add_argument(
        '--org',
        required=True,
        help="Github organization")
    parser.add_argument(
        '--allow-team',
        action='append',
        required=True,
        help='git repos to be tagged MUST be a member of ONE or more of'
             ' these teams (can specify several times)')
    parser.add_argument(
        '--deny-team',
        action='append',
        help='git repos to be tagged MUST NOT be a member of ANY of'
             ' these teams (can specify several times)')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument(
        '--user',
        help='Name of person making the tag - defaults to gitconfig value')
    parser.add_argument(
        '--email',
        help='Email address of tagger - defaults to gitconfig value')
    parser.add_argument(
        '--token-path',
        default='~/.sq_github_token_delete',
        help='Use a token (made with github-auth) in a non-standard location')
    parser.add_argument(
        '--token',
        default=None,
        help='Literal github personal access token string')
    parser.add_argument(
        '-d', '--debug',
        action='count',
        default=os.getenv('DM_SQUARE_DEBUG'),
        help='Debug mode')
    parser.add_argument('-v', '--version', action=codetools.ScmVersionAction)
    return parser.parse_args()


def check_tags(repos, tags, ignore_existing=False, fail_fast=False):
    """ check if tags already exist in repos"""

    debug("looking for {n} tag(s):".format(n=len(tags)))
    [debug("  {t}".format(t=t)) for t in tags]
    debug("in {n} repo(s):".format(n=len(repos)))
    [debug("  {r}".format(r=r.full_name)) for r in repos]

    # present/missing tags by repo name
    present_tags = {}
    absent_tags = {}

    problems = []
    for r in repos:
        has_tags = find_tags_in_repo(r, tags)
        if has_tags and not ignore_existing:
            yikes = GitTagExistsError(
                "tag(s) {tag} already exists in repos {r}".format(
                    tag=list(has_tags.keys()),
                    r=r.full_name
                ))
            if fail_fast:
                raise yikes
            problems.append(yikes)
            error(yikes)

        present_tags[r.full_name] = {
            'repo': r,
            'tags': list(has_tags.values()),
        }

        missing_tags = [x for x in tags if x not in has_tags]
        if missing_tags:
            absent_tags[r.full_name] = {
                'repo': r,
                'need_tags': missing_tags,
            }

    debug(textwrap.dedent("""\
        found:
          {n_with:>4} repos with tag(s)
          {n_none:>4} repos with no tag(s)
          {errors:>4} repos with error(s)\
        """).format(
        n_with=len(present_tags),
        n_none=len(absent_tags),
        errors=len(problems),
    ))

    return present_tags, absent_tags, problems


def find_tags_in_repo(repo, tags):
    assert isinstance(repo, github.Repository.Repository), type(repo)

    debug(textwrap.dedent("""\
        looking in repo: {repo}
          for tag(s): {tags}\
        """).format(
        repo=repo.full_name,
        tags=tags,
    ))

    found_tags = {}
    for t in tags:
        ref = pygithub.find_tag_by_name(repo, t)
        if ref and ref.ref:
            debug("  found: {tag} ({ref})".format(tag=t, ref=ref.ref))
            name = re.sub(r'^refs/tags/', '', ref.ref)
            found_tags[name] = ref
            continue

        debug("  not found: {tag}".format(tag=t))

    return found_tags


cached_teams = {}


def find_repo_teams(repo):
    # Repository objects are unhashable, so we can't use memoization ;(
    if repo.full_name in cached_teams:
        return cached_teams[repo.full_name]

    # flatten iterator so the results are cached
    teams = list(repo.get_teams())
    cached_teams[repo.full_name] = teams

    return teams


def get_candidate_teams(org, target_teams):
    assert isinstance(org, github.Organization.Organization), type(org)

    teams = org.get_teams()

    debug("looking for teams: {teams}".format(teams=target_teams))
    tag_teams = [t for t in teams if t.name in target_teams]
    debug("found teams: {teams}".format(teams=tag_teams))

    if not tag_teams:
        raise RuntimeError('No teams found')

    return tag_teams


def get_candidate_repos(teams):
    # flatten generator to list so it can be itererated over multiple times
    repos = list(pygithub.get_repos_by_team(teams))

    # find length of longest repo name to nicely format output
    names = [r.full_name for r in repos]
    max_name_len = len(max(names, key=len))

    team_names = [t.name for t in teams]
    info("found {n} repo(s) [select by team(s)]:".format(n=len(repos)))
    for r in repos:
        # list only teams which were used to select the repo as a candiate
        # for tagging
        s_teams = [t.name for t in find_repo_teams(r)
                   if t.name in team_names]
        info("  {repo: >{w}} {teams}".format(
            w=max_name_len,
            repo=r.full_name,
            teams=s_teams)
        )

    return repos


def check_repos(repos, allow_teams, deny_teams, fail_fast=False):
    problems = []
    for r in repos:
        try:
            pygithub.check_repo_teams(
                r,
                allow_teams=allow_teams,
                deny_teams=deny_teams,
                team_names=[t.name for t in find_repo_teams(r)],
            )
        except pygithub.RepositoryTeamMembershipError as e:
            if fail_fast:
                raise
            problems.append(e)
            error(e)

            continue

    return problems


def tag_repos(tag_repos, **kwargs):
    info("tagging {n} repo(s) [tags]:".format(n=len(tag_repos)))

    max_name_len = len(max(tag_repos, key=len))
    for k in tag_repos:
        info("  {repo: >{w}} {tags}".format(
            w=max_name_len,
            repo=k,
            tags=tag_repos[k]['need_tags']
        ))

    for k in tag_repos:
        r = tag_repos[k]['repo']
        tags = tag_repos[k]['need_tags']
        create_tags(r, tags, **kwargs)


def create_tags(repo, tags, tagger, dry_run=False):
    # tag the head of the designated "default branch"
    # XXX this probably should be resolved via repos.yaml
    default_branch = repo.default_branch
    head = repo.get_git_ref("heads/{ref}".format(
        ref=default_branch))

    debug(textwrap.dedent("""\
        tagging {repo} @
          default branch: {db}
          type: {obj_type}
          sha: {obj_sha}\
        """).format(
        repo=repo.full_name,
        db=default_branch,
        obj_type=head.object.type,
        obj_sha=head.object.sha
    ))

    for t in tags:
        debug("  adding tag {t}".format(t=t))
        if dry_run:
            debug('    (noop)')
            continue

        tag_obj = repo.create_git_tag(
            t,
            "Version {t}".format(t=t),  # fmt similar to github-tag-version
            head.object.sha,
            head.object.type,
            tagger=tagger
        )
        debug("  created tag object {tag_obj}".format(tag_obj=tag_obj))

        ref = repo.create_git_ref("refs/tags/{t}".format(t=t), tag_obj.sha)
        debug("  created ref: {ref}".format(ref=ref))


def run():
    args = parse_args()

    codetools.setup_logging(args.debug)

    gh_org_name = args.org
    tags = args.tag

    git_email = codetools.lookup_email(args)
    git_user = codetools.lookup_user(args)

    tagger = github.InputGitAuthor(
        git_user,
        git_email,
        codetools.current_timestamp()
    )
    debug(tagger)

    global g
    g = pygithub.login_github(token_path=args.token_path, token=args.token)
    org = g.get_organization(gh_org_name)
    info("tagging repos in org: {org}".format(org=org.login))

    tag_teams = get_candidate_teams(org, args.allow_team)
    target_repos = get_candidate_repos(tag_teams)

    problems = []
    problems += check_repos(
        target_repos,
        args.allow_team,
        args.deny_team,
        fail_fast=False
    )

    # dict
    present_tags, absent_tags, err = check_tags(
        target_repos,
        tags,
        ignore_existing=False
    )
    problems += err

    if problems:
        msg = "{n} repo(s) have errors".format(n=len(problems))
        raise codetools.DogpileError(problems, msg)

    if not absent_tags:
        info('nothing to do')
        return

    tag_repos(absent_tags, tagger=tagger, dry_run=args.dry_run)


def main():
    try:
        run()
    except codetools.DogpileError as e:
        error(e)
        n = len(e.errors)
        sys.exit(n if n < 256 else 255)
    finally:
        if 'g' in globals():
            pygithub.debug_ratelimit(g)


if __name__ == '__main__':
    main()
